{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Go Blueprint - Ultimate Golang Blueprint Library Powerful CLI tool designed to streamline the process of creating Go projects with a robust and standardized structure. Not only does Go Blueprint facilitate project initialization, but it also offers seamless integration with popular Go frameworks, allowing you to focus on your application's code from the very beginning. Why Choose Go Blueprint? Easy Setup and Installation : Go Blueprint simplifies the setup process, making it a breeze to install and get started with your Go projects. Pre-established Go Project Structure : Save time and effort by having the entire Go project structure set up automatically. No need to worry about directory layouts or configuration files. HTTP Server Configuration Made Easy : Whether you prefer Go's standard library HTTP package, Chi, Gin, Fiber, HttpRouter, Gorilla/mux or Echo, Go Blueprint caters to your server setup needs. Focus on Your Application Code : With Go Blueprint handling the project scaffolding, you can dedicate more time and energy to developing your application logic. Project Structure Here's an overview of the project structure created by Go Blueprint when all options are utilized: / (Root) \u251c\u2500\u2500 .github/ \u2502 \u2514\u2500\u2500 workflows/ \u2502 \u251c\u2500\u2500 go-test.yml # GitHub Actions workflow for running tests. \u2502 \u2514\u2500\u2500 release.yml # GitHub Actions workflow for releasing the application. \u251c\u2500\u2500 cmd/ \u2502 \u251c\u2500\u2500 api/ \u2502 \u2502 \u2514\u2500\u2500 main.go # Main file for starting the server. \u2502 \u2514\u2500\u2500 web/ \u2502 \u251c\u2500\u2500 js/ \u2502 \u2502 \u2514\u2500\u2500 htmx.min.js # HTMX library for dynamic HTML content \u2502 \u251c\u2500\u2500 base.templ # Base HTML template file. \u2502 \u251c\u2500\u2500 base.templ.go # Generated Go code for base template \u2502 \u251c\u2500\u2500 efs.go # File for handling file system operations. \u2502 \u251c\u2500\u2500 hello.go # Handler for serving \"hello\" endpoint. \u2502 \u2514\u2500\u2500 hello.templ # Template file for the \"hello\" endpoint. | \u2514\u2500\u2500 hello.templ.go # Generated Go code for the \"hello\" template. \u251c\u2500\u2500 internal/ \u2502 \u251c\u2500\u2500 database/ \u2502 \u2502 \u2514\u2500\u2500 database.go # File containing functions related to database operations. \u2502 \u2514\u2500\u2500 server/ \u2502 \u251c\u2500\u2500 routes.go # File defining HTTP routes. \u2502 \u2514\u2500\u2500 server.go # Main server logic. \u251c\u2500\u2500 tests/ \u2502 \u2514\u2500\u2500 handler_test.go # Test file for testing HTTP handlers. \u251c\u2500\u2500 .air.toml # Configuration file for Air, a live-reload utility. \u251c\u2500\u2500 docker-compose.yml # Docker Compose configuration for defining DB config. \u251c\u2500\u2500 .env # Environment configuration file. \u251c\u2500\u2500 .gitignore # File specifying which files and directories to ignore in Git. \u251c\u2500\u2500 go.mod # Go module file for managing dependencies. \u251c\u2500\u2500 .goreleaser.yml # Configuration file for GoReleaser, a tool for building and releasing binaries. \u251c\u2500\u2500 go.sum # Go module file containing checksums for dependencies. \u251c\u2500\u2500 Makefile # Makefile for defining and running commands. \u2514\u2500\u2500 README.md # Project's README file containing essential information about the project. This structure provides a comprehensive organization of your project, separating source code, tests, configurations and documentation.","title":"Home"},{"location":"#go-blueprint-ultimate-golang-blueprint-library","text":"Powerful CLI tool designed to streamline the process of creating Go projects with a robust and standardized structure. Not only does Go Blueprint facilitate project initialization, but it also offers seamless integration with popular Go frameworks, allowing you to focus on your application's code from the very beginning.","title":"Go Blueprint - Ultimate Golang Blueprint Library"},{"location":"#why-choose-go-blueprint","text":"Easy Setup and Installation : Go Blueprint simplifies the setup process, making it a breeze to install and get started with your Go projects. Pre-established Go Project Structure : Save time and effort by having the entire Go project structure set up automatically. No need to worry about directory layouts or configuration files. HTTP Server Configuration Made Easy : Whether you prefer Go's standard library HTTP package, Chi, Gin, Fiber, HttpRouter, Gorilla/mux or Echo, Go Blueprint caters to your server setup needs. Focus on Your Application Code : With Go Blueprint handling the project scaffolding, you can dedicate more time and energy to developing your application logic.","title":"Why Choose Go Blueprint?"},{"location":"#project-structure","text":"Here's an overview of the project structure created by Go Blueprint when all options are utilized: / (Root) \u251c\u2500\u2500 .github/ \u2502 \u2514\u2500\u2500 workflows/ \u2502 \u251c\u2500\u2500 go-test.yml # GitHub Actions workflow for running tests. \u2502 \u2514\u2500\u2500 release.yml # GitHub Actions workflow for releasing the application. \u251c\u2500\u2500 cmd/ \u2502 \u251c\u2500\u2500 api/ \u2502 \u2502 \u2514\u2500\u2500 main.go # Main file for starting the server. \u2502 \u2514\u2500\u2500 web/ \u2502 \u251c\u2500\u2500 js/ \u2502 \u2502 \u2514\u2500\u2500 htmx.min.js # HTMX library for dynamic HTML content \u2502 \u251c\u2500\u2500 base.templ # Base HTML template file. \u2502 \u251c\u2500\u2500 base.templ.go # Generated Go code for base template \u2502 \u251c\u2500\u2500 efs.go # File for handling file system operations. \u2502 \u251c\u2500\u2500 hello.go # Handler for serving \"hello\" endpoint. \u2502 \u2514\u2500\u2500 hello.templ # Template file for the \"hello\" endpoint. | \u2514\u2500\u2500 hello.templ.go # Generated Go code for the \"hello\" template. \u251c\u2500\u2500 internal/ \u2502 \u251c\u2500\u2500 database/ \u2502 \u2502 \u2514\u2500\u2500 database.go # File containing functions related to database operations. \u2502 \u2514\u2500\u2500 server/ \u2502 \u251c\u2500\u2500 routes.go # File defining HTTP routes. \u2502 \u2514\u2500\u2500 server.go # Main server logic. \u251c\u2500\u2500 tests/ \u2502 \u2514\u2500\u2500 handler_test.go # Test file for testing HTTP handlers. \u251c\u2500\u2500 .air.toml # Configuration file for Air, a live-reload utility. \u251c\u2500\u2500 docker-compose.yml # Docker Compose configuration for defining DB config. \u251c\u2500\u2500 .env # Environment configuration file. \u251c\u2500\u2500 .gitignore # File specifying which files and directories to ignore in Git. \u251c\u2500\u2500 go.mod # Go module file for managing dependencies. \u251c\u2500\u2500 .goreleaser.yml # Configuration file for GoReleaser, a tool for building and releasing binaries. \u251c\u2500\u2500 go.sum # Go module file containing checksums for dependencies. \u251c\u2500\u2500 Makefile # Makefile for defining and running commands. \u2514\u2500\u2500 README.md # Project's README file containing essential information about the project. This structure provides a comprehensive organization of your project, separating source code, tests, configurations and documentation.","title":"Project Structure"},{"location":"installation/","text":"Installation Go-Blueprint provides a convenient CLI tool to effortlessly set up your Go projects. Follow the steps below to install the tool on your system. Binary Installation To install the Go-Blueprint CLI tool as a binary, Run the following command: go install github.com/melkeydev/go-blueprint@latest This command installs the Go-Blueprint binary, automatically binding it to your $GOPATH . Building and Installing from Source If you prefer to build and install Go-Blueprint directly from the source code, you can follow these steps: Clone the Go-Blueprint repository from GitHub: git clone https://github.com/melkeydev/go-blueprint Build the Go-Blueprint binary: go build Install in your $PATH to make it accessible system-wide: go install Verify the installation by running: go-blueprint version This should display the version information of the installed Go-Blueprint. Now you have successfully built and installed Go-Blueprint from the source code.","title":"Installation"},{"location":"installation/#installation","text":"Go-Blueprint provides a convenient CLI tool to effortlessly set up your Go projects. Follow the steps below to install the tool on your system.","title":"Installation"},{"location":"installation/#binary-installation","text":"To install the Go-Blueprint CLI tool as a binary, Run the following command: go install github.com/melkeydev/go-blueprint@latest This command installs the Go-Blueprint binary, automatically binding it to your $GOPATH .","title":"Binary Installation"},{"location":"installation/#building-and-installing-from-source","text":"If you prefer to build and install Go-Blueprint directly from the source code, you can follow these steps: Clone the Go-Blueprint repository from GitHub: git clone https://github.com/melkeydev/go-blueprint Build the Go-Blueprint binary: go build Install in your $PATH to make it accessible system-wide: go install Verify the installation by running: go-blueprint version This should display the version information of the installed Go-Blueprint. Now you have successfully built and installed Go-Blueprint from the source code.","title":"Building and Installing from Source"},{"location":"advanced-flag/advanced-flag/","text":"Advanced Flag in Blueprint The --advanced flag in Blueprint serves as a switch to enable additional features during project creation. It is applied with the create command and unlocks the following features: HTMX Support using Templ: Enables the integration of HTMX support for dynamic web pages using Templ. CI/CD Workflow Setup using GitHub Actions: Automates the setup of a CI/CD workflow using GitHub Actions. Websocket Support: WebSocket endpoint that sends continuous data streams through the WS protocol. To utilize the --advanced flag, use the following command: go-blueprint create --name <project_name> --framework <selected_framework> --driver <selected_driver> --advanced By including the --advanced flag, users can choose one or all of the advanced features. The flag enhances the simplicity of Blueprint while offering flexibility for users who require additional functionality. To recreate the project using the same configuration semi-interactively, use the following command: go-blueprint create --name my-project --framework chi --driver mysql --advanced Non-Interactive Setup is also possible: go-blueprint create --name my-project --framework chi --driver mysql --advanced --feature htmx --feature githubaction --feature websocket","title":"AF Usage"},{"location":"advanced-flag/advanced-flag/#advanced-flag-in-blueprint","text":"The --advanced flag in Blueprint serves as a switch to enable additional features during project creation. It is applied with the create command and unlocks the following features: HTMX Support using Templ: Enables the integration of HTMX support for dynamic web pages using Templ. CI/CD Workflow Setup using GitHub Actions: Automates the setup of a CI/CD workflow using GitHub Actions. Websocket Support: WebSocket endpoint that sends continuous data streams through the WS protocol. To utilize the --advanced flag, use the following command: go-blueprint create --name <project_name> --framework <selected_framework> --driver <selected_driver> --advanced By including the --advanced flag, users can choose one or all of the advanced features. The flag enhances the simplicity of Blueprint while offering flexibility for users who require additional functionality. To recreate the project using the same configuration semi-interactively, use the following command: go-blueprint create --name my-project --framework chi --driver mysql --advanced Non-Interactive Setup is also possible: go-blueprint create --name my-project --framework chi --driver mysql --advanced --feature htmx --feature githubaction --feature websocket","title":"Advanced Flag in Blueprint"},{"location":"advanced-flag/goreleaser/","text":"GoReleaser - Automating Releases with GoReleaser Release process for Go projects, providing extensive customization options through its configuration file, .goreleaser.yml . By default, it ensures dependency cleanliness, builds binaries for various platforms and architectures, facilitates pre-release creation, and organizes binary packaging into archives with naming schemes. For comprehensive insights into customization possibilities, refer to the GoReleaser documentation . Usage with Tags To initiate release builds with GoReleaser, you need to follow these steps: Tag Creation: When your project is ready for a release, create a new tag in your Git repository. For example: git tag v1.0.0 Tag Pushing: Push the tag to the repository to trigger GoReleaser: git push origin v1.0.0 Following these steps ensures proper tagging of your project, prompting GoReleaser to execute configured releases. This approach simplifies release management and automates artifact distribution. Go Test - Continuous Integration for Go Projects The go-test.yml file defines a GitHub Actions workflow for continuous integration (CI) of Go projects within a GitHub repository. Workflow Steps The job outlined in this workflow includes the following steps: Checkout: Fetches the project's codebase from the repository. Go Setup: Configures the Go environment with version 1.21.x. Build and Test: Builds the project using go build and runs tests across all packages ( ./... ) using go test . This workflow serves to automate the testing process of a Go project within a GitHub repository, ensuring code quality and reliability with each commit and pull request.","title":"GoReleaser & GoTest CI"},{"location":"advanced-flag/goreleaser/#goreleaser-automating-releases-with-goreleaser","text":"Release process for Go projects, providing extensive customization options through its configuration file, .goreleaser.yml . By default, it ensures dependency cleanliness, builds binaries for various platforms and architectures, facilitates pre-release creation, and organizes binary packaging into archives with naming schemes. For comprehensive insights into customization possibilities, refer to the GoReleaser documentation .","title":"GoReleaser - Automating Releases with GoReleaser"},{"location":"advanced-flag/goreleaser/#usage-with-tags","text":"To initiate release builds with GoReleaser, you need to follow these steps: Tag Creation: When your project is ready for a release, create a new tag in your Git repository. For example: git tag v1.0.0 Tag Pushing: Push the tag to the repository to trigger GoReleaser: git push origin v1.0.0 Following these steps ensures proper tagging of your project, prompting GoReleaser to execute configured releases. This approach simplifies release management and automates artifact distribution.","title":"Usage with Tags"},{"location":"advanced-flag/goreleaser/#go-test-continuous-integration-for-go-projects","text":"The go-test.yml file defines a GitHub Actions workflow for continuous integration (CI) of Go projects within a GitHub repository.","title":"Go Test - Continuous Integration for Go Projects"},{"location":"advanced-flag/goreleaser/#workflow-steps","text":"The job outlined in this workflow includes the following steps: Checkout: Fetches the project's codebase from the repository. Go Setup: Configures the Go environment with version 1.21.x. Build and Test: Builds the project using go build and runs tests across all packages ( ./... ) using go test . This workflow serves to automate the testing process of a Go project within a GitHub repository, ensuring code quality and reliability with each commit and pull request.","title":"Workflow Steps"},{"location":"advanced-flag/htmx-tmpl/","text":"HTMX and Templ Setup The WEB directory contains the web-related components and assets for the project. It leverages htmx and tmpl in Go for dynamic web content generation. Structure web/ \u2502 \u251c\u2500\u2500 js/ \u2502 \u2514\u2500\u2500 htmx.min.js # htmx library for dynamic HTML content \u2502 \u251c\u2500\u2500 base.templ # Base template for HTML structure \u251c\u2500\u2500 base_templ.go # Generated Go code for base template \u251c\u2500\u2500 efs.go # Embeds static files (e.g., JavaScript) into the Go binary \u2502 \u251c\u2500\u2500 hello.go # Handler for the Hello Web functionality \u251c\u2500\u2500 hello.templ # Template for rendering the Hello form and post data \u2514\u2500\u2500 hello_templ.go # Generated Go code for hello template Usage Navigate to Project Directory: cd my-project Install Templ CLI: go install github.com/a-h/templ/cmd/templ@latest Generate Templ Function Files: templ generate Start Server: make run Templating Templates are generated using the templ generate command after project creation. These templates are then compiled into Go code for efficient execution. You can test HTMX functionality on localhost:port/web endpoint.","title":"HTMX and Templ"},{"location":"advanced-flag/htmx-tmpl/#htmx-and-templ-setup","text":"The WEB directory contains the web-related components and assets for the project. It leverages htmx and tmpl in Go for dynamic web content generation.","title":"HTMX and Templ Setup"},{"location":"advanced-flag/htmx-tmpl/#structure","text":"web/ \u2502 \u251c\u2500\u2500 js/ \u2502 \u2514\u2500\u2500 htmx.min.js # htmx library for dynamic HTML content \u2502 \u251c\u2500\u2500 base.templ # Base template for HTML structure \u251c\u2500\u2500 base_templ.go # Generated Go code for base template \u251c\u2500\u2500 efs.go # Embeds static files (e.g., JavaScript) into the Go binary \u2502 \u251c\u2500\u2500 hello.go # Handler for the Hello Web functionality \u251c\u2500\u2500 hello.templ # Template for rendering the Hello form and post data \u2514\u2500\u2500 hello_templ.go # Generated Go code for hello template","title":"Structure"},{"location":"advanced-flag/htmx-tmpl/#usage","text":"Navigate to Project Directory: cd my-project Install Templ CLI: go install github.com/a-h/templ/cmd/templ@latest Generate Templ Function Files: templ generate Start Server: make run","title":"Usage"},{"location":"advanced-flag/htmx-tmpl/#templating","text":"Templates are generated using the templ generate command after project creation. These templates are then compiled into Go code for efficient execution. You can test HTMX functionality on localhost:port/web endpoint.","title":"Templating"},{"location":"advanced-flag/websocket/","text":"Websocket A /websocket endpoint is added in routes.go to facilitate websocket connections. Upon accessing this endpoint, the server establishes a websocket connection and begins transmitting timestamp messages at 2-second intervals. WS is utilized across all Go-blueprint supported frameworks. This simple implementation showcases how flexible project is. Testing with WebSocat WebSocat is a versatile tool for working with websockets from the command line. Below are some examples of using WebSocat to test the websocket endpoint: # Start server make run # Connect to the websocket endpoint $ websocat ws://localhost:PORT/websocket Replace PORT with the port number on which your server is running. Expected Output Upon successful connection, the client should start receiving timestamp messages from the server every 2 seconds. server timestamp: 1709046650354893857 server timestamp: 1709046652355956336 server timestamp: 1709046654357101642 server timestamp: 1709046656357202535 server timestamp: 1709046658358258120 server timestamp: 1709046660359338389 server timestamp: 1709046662360422533 server timestamp: 1709046664361194735 server timestamp: 1709046666362308678 server timestamp: 1709046668363390475 server timestamp: 1709046670364477838 server timestamp: 1709046672365193667 server timestamp: 1709046674366265199 server timestamp: 1709046676366564490 server timestamp: 1709046678367646090 server timestamp: 1709046680367851980 server timestamp: 1709046682368920527 You can utilize alternative tools that support the WebSocket protocol to establish connections with the server. WebSocat is an open-source CLI tool, while POSTMAN serves as a GUI tool specifically designed for testing APIs and WebSocket functionality.","title":"Websocket"},{"location":"advanced-flag/websocket/#websocket","text":"A /websocket endpoint is added in routes.go to facilitate websocket connections. Upon accessing this endpoint, the server establishes a websocket connection and begins transmitting timestamp messages at 2-second intervals. WS is utilized across all Go-blueprint supported frameworks. This simple implementation showcases how flexible project is.","title":"Websocket"},{"location":"advanced-flag/websocket/#testing-with-websocat","text":"WebSocat is a versatile tool for working with websockets from the command line. Below are some examples of using WebSocat to test the websocket endpoint: # Start server make run # Connect to the websocket endpoint $ websocat ws://localhost:PORT/websocket Replace PORT with the port number on which your server is running.","title":"Testing with WebSocat"},{"location":"advanced-flag/websocket/#expected-output","text":"Upon successful connection, the client should start receiving timestamp messages from the server every 2 seconds. server timestamp: 1709046650354893857 server timestamp: 1709046652355956336 server timestamp: 1709046654357101642 server timestamp: 1709046656357202535 server timestamp: 1709046658358258120 server timestamp: 1709046660359338389 server timestamp: 1709046662360422533 server timestamp: 1709046664361194735 server timestamp: 1709046666362308678 server timestamp: 1709046668363390475 server timestamp: 1709046670364477838 server timestamp: 1709046672365193667 server timestamp: 1709046674366265199 server timestamp: 1709046676366564490 server timestamp: 1709046678367646090 server timestamp: 1709046680367851980 server timestamp: 1709046682368920527 You can utilize alternative tools that support the WebSocket protocol to establish connections with the server. WebSocat is an open-source CLI tool, while POSTMAN serves as a GUI tool specifically designed for testing APIs and WebSocket functionality.","title":"Expected Output"},{"location":"blueprint-core/db-drivers/","text":"Database Drivers To extend the project with database functionality, users can choose from a variety of Go database drivers. Each driver is tailored to work with specific database systems, providing flexibility based on project requirements: Mongo : Provides necessary tools for connecting and interacting with MongoDB databases. Mysql : Enables seamless integration with MySQL databases. Postgres : Facilitates connectivity to PostgreSQL databases. Redis : Provides tools for connecting and interacting with Redis. Sqlite : Suitable for projects requiring a lightweight, self-contained database. and interacting with Redis Updated Project Structure Integrating a database adds a new layer to the project structure, primarily in the internal/database directory: /(Root) \u251c\u2500\u2500 /cmd \u2502 \u2514\u2500\u2500 /api \u2502 \u2514\u2500\u2500 main.go \u251c\u2500\u2500 /internal \u2502 \u251c\u2500\u2500 /database \u2502 \u2502 \u2514\u2500\u2500 database.go \u2502 \u2514\u2500\u2500 /server \u2502 \u251c\u2500\u2500 routes.go \u2502 \u2514\u2500\u2500 server.go \u251c\u2500\u2500 /tests \u2502 \u2514\u2500\u2500 handler_test.go \u251c\u2500\u2500 go.mod \u251c\u2500\u2500 go.sum \u251c\u2500\u2500 Makefile \u2514\u2500\u2500 README.md Database Driver Implementation Users can select the desired database driver based on their project's specific needs. The chosen driver is then imported into the project, and the database.go file is adjusted accordingly to establish a connection and manage interactions with the selected database. Docker-Compose for Quick Database Spinup To facilitate quick setup and testing, a docker-compose.yml file is provided. This file defines a service for the chosen database system with the necessary environment variables. Running docker-compose up will quickly spin up a containerized instance of the database, allowing users to test their application against a real database server. This Docker Compose approach simplifies the process of setting up a database for development or testing purposes, providing a convenient and reproducible environment for the project.","title":"DB Drivers"},{"location":"blueprint-core/db-drivers/#database-drivers","text":"To extend the project with database functionality, users can choose from a variety of Go database drivers. Each driver is tailored to work with specific database systems, providing flexibility based on project requirements: Mongo : Provides necessary tools for connecting and interacting with MongoDB databases. Mysql : Enables seamless integration with MySQL databases. Postgres : Facilitates connectivity to PostgreSQL databases. Redis : Provides tools for connecting and interacting with Redis. Sqlite : Suitable for projects requiring a lightweight, self-contained database. and interacting with Redis","title":"Database Drivers"},{"location":"blueprint-core/db-drivers/#updated-project-structure","text":"Integrating a database adds a new layer to the project structure, primarily in the internal/database directory: /(Root) \u251c\u2500\u2500 /cmd \u2502 \u2514\u2500\u2500 /api \u2502 \u2514\u2500\u2500 main.go \u251c\u2500\u2500 /internal \u2502 \u251c\u2500\u2500 /database \u2502 \u2502 \u2514\u2500\u2500 database.go \u2502 \u2514\u2500\u2500 /server \u2502 \u251c\u2500\u2500 routes.go \u2502 \u2514\u2500\u2500 server.go \u251c\u2500\u2500 /tests \u2502 \u2514\u2500\u2500 handler_test.go \u251c\u2500\u2500 go.mod \u251c\u2500\u2500 go.sum \u251c\u2500\u2500 Makefile \u2514\u2500\u2500 README.md","title":"Updated Project Structure"},{"location":"blueprint-core/db-drivers/#database-driver-implementation","text":"Users can select the desired database driver based on their project's specific needs. The chosen driver is then imported into the project, and the database.go file is adjusted accordingly to establish a connection and manage interactions with the selected database.","title":"Database Driver Implementation"},{"location":"blueprint-core/db-drivers/#docker-compose-for-quick-database-spinup","text":"To facilitate quick setup and testing, a docker-compose.yml file is provided. This file defines a service for the chosen database system with the necessary environment variables. Running docker-compose up will quickly spin up a containerized instance of the database, allowing users to test their application against a real database server. This Docker Compose approach simplifies the process of setting up a database for development or testing purposes, providing a convenient and reproducible environment for the project.","title":"Docker-Compose for Quick Database Spinup"},{"location":"blueprint-core/frameworks/","text":"Frameworks Created project can utilizes several Go web frameworks to handle HTTP routing and server functionality. The chosen frameworks are: Chi : Lightweight and flexible router for building Go HTTP services. Echo : High-performance, extensible, minimalist Go web framework. Fiber : Express-inspired web framework designed to be fast, simple, and efficient. Gin : A web framework with a martini-like API, but with much better performance. Gorilla/mux : A powerful URL router and dispatcher for Golang. HttpRouter : A high-performance HTTP request router that scales well. Project Structure The project is structured with a simple layout, focusing on the cmd, internal, and tests directories: /(Root) \u251c\u2500\u2500 /cmd \u2502 \u2514\u2500\u2500 /api \u2502 \u2514\u2500\u2500 main.go \u251c\u2500\u2500 /internal \u2502 \u2514\u2500\u2500 /server \u2502 \u251c\u2500\u2500 routes.go \u2502 \u2514\u2500\u2500 server.go \u251c\u2500\u2500 /tests \u2502 \u2514\u2500\u2500 handler_test.go \u251c\u2500\u2500 go.mod \u251c\u2500\u2500 go.sum \u251c\u2500\u2500 Makefile \u2514\u2500\u2500 README.md","title":"Frameworks"},{"location":"blueprint-core/frameworks/#frameworks","text":"Created project can utilizes several Go web frameworks to handle HTTP routing and server functionality. The chosen frameworks are: Chi : Lightweight and flexible router for building Go HTTP services. Echo : High-performance, extensible, minimalist Go web framework. Fiber : Express-inspired web framework designed to be fast, simple, and efficient. Gin : A web framework with a martini-like API, but with much better performance. Gorilla/mux : A powerful URL router and dispatcher for Golang. HttpRouter : A high-performance HTTP request router that scales well.","title":"Frameworks"},{"location":"blueprint-core/frameworks/#project-structure","text":"The project is structured with a simple layout, focusing on the cmd, internal, and tests directories: /(Root) \u251c\u2500\u2500 /cmd \u2502 \u2514\u2500\u2500 /api \u2502 \u2514\u2500\u2500 main.go \u251c\u2500\u2500 /internal \u2502 \u2514\u2500\u2500 /server \u2502 \u251c\u2500\u2500 routes.go \u2502 \u2514\u2500\u2500 server.go \u251c\u2500\u2500 /tests \u2502 \u2514\u2500\u2500 handler_test.go \u251c\u2500\u2500 go.mod \u251c\u2500\u2500 go.sum \u251c\u2500\u2500 Makefile \u2514\u2500\u2500 README.md","title":"Project Structure"},{"location":"creating-project/air/","text":"Air - Live Reloading Utility Air is a live-reloading utility designed to enhance the development experience by automatically rebuilding and restarting your Go application whenever changes are detected in the source code. The Makefile provided in the project repository includes a command make watch, which triggers Air to monitor file changes and initiate rebuilds and restarts as necessary. Additionally, if Air is not installed on your machine, the Makefile provides an option to install it automatically. Air's .air.toml configuration file allows customization of various aspects of its behavior. Live Preview make watch __ _ ___ / /\\ | | | |_) /_/--\\ |_| |_| \\_ v1.51.0, built with Go go1.22.0 mkdir /home/ujstor/code/blueprint-version-test/ws-test4/tmp watching . watching cmd watching cmd/api watching cmd/web watching cmd/web/js watching internal watching internal/database watching internal/server watching tests !exclude tmp building... make[1]: Entering directory '/home/ujstor/code/blueprint-version-test/ws-test4' Building... Processing path: /home/ujstor/code/blueprint-version-test/ws-test4 Generated code for \"/home/ujstor/code/blueprint-version-test/ws-test4/cmd/web/base.templ\" in 914.556\u00b5s Generated code for \"/home/ujstor/code/blueprint-version-test/ws-test4/cmd/web/hello.templ\" in 963.157\u00b5s Generated code for 2 templates with 0 errors in 1.274392ms make[1]: Leaving directory '/home/ujstor/code/blueprint-version-test/ws-test4' running... internal/server/routes.go has changed building... make[1]: Entering directory '/home/ujstor/code/blueprint-version-test/ws-test4' Building... Processing path: /home/ujstor/code/blueprint-version-test/ws-test4 Generated code for \"/home/ujstor/code/blueprint-version-test/ws-test4/cmd/web/base.templ\" in 907.426\u00b5s Generated code for \"/home/ujstor/code/blueprint-version-test/ws-test4/cmd/web/hello.templ\" in 1.16142ms Generated code for 2 templates with 0 errors in 1.527556ms make[1]: Leaving directory '/home/ujstor/code/blueprint-version-test/ws-test4' running... Integrating Air into your development workflow alongside the provided Makefile enables a smooth and efficient process for building, testing, and running your Go applications. With automatic live-reloading, you can focus more on coding and less on manual build and restart steps.","title":"Air"},{"location":"creating-project/air/#air-live-reloading-utility","text":"Air is a live-reloading utility designed to enhance the development experience by automatically rebuilding and restarting your Go application whenever changes are detected in the source code. The Makefile provided in the project repository includes a command make watch, which triggers Air to monitor file changes and initiate rebuilds and restarts as necessary. Additionally, if Air is not installed on your machine, the Makefile provides an option to install it automatically. Air's .air.toml configuration file allows customization of various aspects of its behavior.","title":"Air - Live Reloading Utility"},{"location":"creating-project/air/#live-preview","text":"make watch __ _ ___ / /\\ | | | |_) /_/--\\ |_| |_| \\_ v1.51.0, built with Go go1.22.0 mkdir /home/ujstor/code/blueprint-version-test/ws-test4/tmp watching . watching cmd watching cmd/api watching cmd/web watching cmd/web/js watching internal watching internal/database watching internal/server watching tests !exclude tmp building... make[1]: Entering directory '/home/ujstor/code/blueprint-version-test/ws-test4' Building... Processing path: /home/ujstor/code/blueprint-version-test/ws-test4 Generated code for \"/home/ujstor/code/blueprint-version-test/ws-test4/cmd/web/base.templ\" in 914.556\u00b5s Generated code for \"/home/ujstor/code/blueprint-version-test/ws-test4/cmd/web/hello.templ\" in 963.157\u00b5s Generated code for 2 templates with 0 errors in 1.274392ms make[1]: Leaving directory '/home/ujstor/code/blueprint-version-test/ws-test4' running... internal/server/routes.go has changed building... make[1]: Entering directory '/home/ujstor/code/blueprint-version-test/ws-test4' Building... Processing path: /home/ujstor/code/blueprint-version-test/ws-test4 Generated code for \"/home/ujstor/code/blueprint-version-test/ws-test4/cmd/web/base.templ\" in 907.426\u00b5s Generated code for \"/home/ujstor/code/blueprint-version-test/ws-test4/cmd/web/hello.templ\" in 1.16142ms Generated code for 2 templates with 0 errors in 1.527556ms make[1]: Leaving directory '/home/ujstor/code/blueprint-version-test/ws-test4' running... Integrating Air into your development workflow alongside the provided Makefile enables a smooth and efficient process for building, testing, and running your Go applications. With automatic live-reloading, you can focus more on coding and less on manual build and restart steps.","title":"Live Preview"},{"location":"creating-project/endpoints-test/","text":"Testing Endpoints with CURL and WebSocat Testing endpoints is an essential part of ensuring the correctness and functionality of your app. Depending on what options are used for go-blueprint project creation, you have various endpoints for testing your init application status. Before proceeding, ensure you have the following tools installed: CURL : A command-line tool for transferring data with URLs. WebSocat : A command-line WebSocket client. Hello World Endpoint To test the Hello World endpoint, execute the following curl command: curl http://localhost:PORT Expected Output: {\"message\": \"Hello World\"} DB Health Check Endpoint To test the DB Health Check endpoint, use the following curl command: curl http://localhost:PORT/health Expected Output: {\"message\": \"It's healthy\"} WebSocket Endpoint Initiate a WebSocket connection: websocat ws://localhost:PORT/websocket Expected Output: server timestamp: 1709046650354893857 server timestamp: 1709046652355956336 server timestamp: 1709046654357101642 server timestamp: 1709046656357202535 Testing /web Endpoint To test the /web endpoint, you can simply open it in a web browser. This endpoint serves a simple HTML page with a form. Navigate to http://localhost:PORT/web This page contains a form with a single input field and a submit button. Upon submitting the form, \"Hello, [input]\" will be displayed.","title":"Testing endpoints"},{"location":"creating-project/endpoints-test/#testing-endpoints-with-curl-and-websocat","text":"Testing endpoints is an essential part of ensuring the correctness and functionality of your app. Depending on what options are used for go-blueprint project creation, you have various endpoints for testing your init application status. Before proceeding, ensure you have the following tools installed: CURL : A command-line tool for transferring data with URLs. WebSocat : A command-line WebSocket client.","title":"Testing Endpoints with CURL and WebSocat"},{"location":"creating-project/endpoints-test/#hello-world-endpoint","text":"To test the Hello World endpoint, execute the following curl command: curl http://localhost:PORT Expected Output: {\"message\": \"Hello World\"}","title":"Hello World Endpoint"},{"location":"creating-project/endpoints-test/#db-health-check-endpoint","text":"To test the DB Health Check endpoint, use the following curl command: curl http://localhost:PORT/health Expected Output: {\"message\": \"It's healthy\"}","title":"DB Health Check Endpoint"},{"location":"creating-project/endpoints-test/#websocket-endpoint","text":"Initiate a WebSocket connection: websocat ws://localhost:PORT/websocket Expected Output: server timestamp: 1709046650354893857 server timestamp: 1709046652355956336 server timestamp: 1709046654357101642 server timestamp: 1709046656357202535","title":"WebSocket Endpoint"},{"location":"creating-project/endpoints-test/#testing-web-endpoint","text":"To test the /web endpoint, you can simply open it in a web browser. This endpoint serves a simple HTML page with a form. Navigate to http://localhost:PORT/web This page contains a form with a single input field and a submit button. Upon submitting the form, \"Hello, [input]\" will be displayed.","title":"Testing /web Endpoint"},{"location":"creating-project/makefile/","text":"Makefile Project Management This Makefile is included as a default after project creation. It offers a set of commands to simplify various development tasks for managing a Go project. Commands Build the Application: Compiles the application and generates the executable. make build Run the Application: Executes the application using go run . make run Create DB Container: Utilizes Docker Compose to set up the database container. It includes a fallback for Docker Compose V1. make docker-run Shutdown DB Container: Stops and removes the database container. It also has a fallback for Docker Compose V1. make docker-down Test the Application: Executes tests defined in the ./tests directory. make test Clean the Binary: Removes the generated binary file. make clean Live Reload: Monitors file changes and automatically rebuilds and restarts the application using air . make watch Makefile simplifies common development tasks, making it easier to build, run, test, and manage dependencies in a Go project. It enhances productivity by providing a standardized approach to project management.","title":"Makefile"},{"location":"creating-project/makefile/#makefile-project-management","text":"This Makefile is included as a default after project creation. It offers a set of commands to simplify various development tasks for managing a Go project.","title":"Makefile Project Management"},{"location":"creating-project/makefile/#commands","text":"Build the Application: Compiles the application and generates the executable. make build Run the Application: Executes the application using go run . make run Create DB Container: Utilizes Docker Compose to set up the database container. It includes a fallback for Docker Compose V1. make docker-run Shutdown DB Container: Stops and removes the database container. It also has a fallback for Docker Compose V1. make docker-down Test the Application: Executes tests defined in the ./tests directory. make test Clean the Binary: Removes the generated binary file. make clean Live Reload: Monitors file changes and automatically rebuilds and restarts the application using air . make watch Makefile simplifies common development tasks, making it easier to build, run, test, and manage dependencies in a Go project. It enhances productivity by providing a standardized approach to project management.","title":"Commands"},{"location":"creating-project/project-init/","text":"Creating a Project After installing the Go-Blueprint CLI tool, you can create a new project with the default settings by running the following command: go-blueprint create This command will interactively guide you through the project setup process, allowing you to choose the project name, framework, and database driver. Using Flags for Non-Interactive Setup For a non-interactive setup, you can use flags to provide the necessary information during project creation. Here's an example: go-blueprint create --name my-project --framework gin --driver postgres In this example: --name : Specifies the name of the project (replace \"my-project\" with your desired project name). --framework : Specifies the Go framework to be used (e.g., \"gin\"). --driver : Specifies the database driver to be integrated (e.g., \"postgres\"). Customize the flags according to your project requirements. Advanced Flag By including the --advanced flag, users can choose one or all of the advanced features, HTMX, GitHub Actions for CI/CD and Websocket support, during the project creation process. The flag enhances the simplicity of Blueprint while offering flexibility for users who require additional functionality. go-blueprint create --advanced To recreate the project using the same configuration semi-interactively, use the following command: go-blueprint create --name my-project --framework chi --driver mysql --advanced This approach opens interactive mode only for advanced features, which allow you to choose the one or combination of available features. Non-Interactive Setup Advanced features can be enabled using the --feature flag along with the --advanced flag: For HTMX: go-blueprint create --advanced --feature htmx For the CI/CD workflow: go-blueprint create --advanced --feature githubaction For the websocket: go-blueprint create --advanced --feature websocket Or all features at once: go-blueprint create --name my-project --framework chi --driver mysql --advanced --feature htmx --feature githubaction --feature websocket","title":"Project init"},{"location":"creating-project/project-init/#creating-a-project","text":"After installing the Go-Blueprint CLI tool, you can create a new project with the default settings by running the following command: go-blueprint create This command will interactively guide you through the project setup process, allowing you to choose the project name, framework, and database driver.","title":"Creating a Project"},{"location":"creating-project/project-init/#using-flags-for-non-interactive-setup","text":"For a non-interactive setup, you can use flags to provide the necessary information during project creation. Here's an example: go-blueprint create --name my-project --framework gin --driver postgres In this example: --name : Specifies the name of the project (replace \"my-project\" with your desired project name). --framework : Specifies the Go framework to be used (e.g., \"gin\"). --driver : Specifies the database driver to be integrated (e.g., \"postgres\"). Customize the flags according to your project requirements.","title":"Using Flags for Non-Interactive Setup"},{"location":"creating-project/project-init/#advanced-flag","text":"By including the --advanced flag, users can choose one or all of the advanced features, HTMX, GitHub Actions for CI/CD and Websocket support, during the project creation process. The flag enhances the simplicity of Blueprint while offering flexibility for users who require additional functionality. go-blueprint create --advanced To recreate the project using the same configuration semi-interactively, use the following command: go-blueprint create --name my-project --framework chi --driver mysql --advanced This approach opens interactive mode only for advanced features, which allow you to choose the one or combination of available features.","title":"Advanced Flag"},{"location":"creating-project/project-init/#non-interactive-setup","text":"Advanced features can be enabled using the --feature flag along with the --advanced flag: For HTMX: go-blueprint create --advanced --feature htmx For the CI/CD workflow: go-blueprint create --advanced --feature githubaction For the websocket: go-blueprint create --advanced --feature websocket Or all features at once: go-blueprint create --name my-project --framework chi --driver mysql --advanced --feature htmx --feature githubaction --feature websocket","title":"Non-Interactive Setup"}]}